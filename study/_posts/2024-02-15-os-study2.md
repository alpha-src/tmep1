---
layout: post
title: 퇴근 후 운영체제 시리즈 - 컴퓨터 시스템의 구조
description: >
    운영체제 스터디 기록
hide_description: false
category: study
image:
  path: https://user-images.githubusercontent.com/54366260/235833580-f3259d21-36fc-4866-8d0e-dfa47fa3e594.png
---

**해당 썸네일은 `Wonkook Lee` 님이 만드신 [`Thumbnail-Maker`](https://wonkooklee.github.io/thumbnail_maker/){:target="_blank"} 를 이용하였습니다**
{:.figcaption}

* this unordered seed list will be replaced by the toc
{:toc}


# 운영체제란?

> 컴퓨터 하드웨어 바로 위에 설치된 SW와 HW를 연결해주는 소프트웨어 계층
> 

- 협의의 운영체제(커널)
    - 운영체제의 핵심 부분으로 **메모리에 상주하는 부분**
- 광의의 운영체제
    - 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념
    

# 운영체제의 목적

> 컴퓨터 시스템의 자원을 효율적으로 관리
> 
- 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
- 사용자 및 운영체제 보호
- 프로세스, 파일, 메시지 관리

→ 어떤 프로세스에게 얼만큼의 메모리를 주어야 하는가 → OS의 주요 핵심

# 운영체제의 분류


> 🛩️ **동시 작업 가능 여부 / 사용자의 수 / 처리 방식**
{:.lead}

## 동시 작업 가능 여부

> 요즘은 멀티태스킹이 기본이기에 메모리 관리가 더 중요해지는 것
> 
- Single Tasking
    - 한번에 하나의 작업만 처리
- Multi Tasking
    - 동시에 두개 이상의 작업 처리

## 사용자의 수

> 동시에 접속 가능한가? → 파일 관리가 더 중요해지고 보안에 신경써야됨
> 
- 단일 사용자
- 다중 사용자

## 처리 방식

### 일괄 처리 (Batch Processing) - 현대에는 맞지 않음

- 작업 요청의 일정량 모아서 **한꺼번에 처리**
- 완전 종료될 때까지 기다려야됨

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/90dea9ef-c62b-4dab-928d-bfe29b34426e)

### 시분할 (Time Sharing) - 범용

- 여러 작업을 수행할 때 **컴퓨터 처리 능력을 일정한 시간 단위로 분할**
- 짧은 응답 시간
- interactive 한 방식

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/e1b191c8-09d1-4da0-8c45-6289bb8bb7ba)

### 실시간 (Realtime OS)

- 정해진 시간(Deadline) 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 시스템
    - 원자로 / 공장 제어, 미사일, 반도체, 로봇
- 우리가 쓰는 운영체제는 실시간 시스템이 아님 → 그럴 필요가 없고 목적이 다름

```
몇 가지 용어

* Multitasking : 
* Multi programming : 메모리 측면을 강조한 것
* Multi Processor : 하나의 컴퓨터에 **CPU(Processor)가 여러 개** 붙어있는 것을 의미함
	* 복잡한 문제들이 생김 -> 병렬적으로 어떻게 처리할건가?
	
우리는 **CPU가 하나 있다고 생각하고 수업을 진행**
```

---

# 컴퓨터 시스템 구조

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/032a8c5f-5c21-4e3f-bf8c-0532117dd213)

**각각의 컨트롤러들은 로컬 버퍼라는 작업 공간을 가지고 CPU와 상호작용**

- CPU가 운영체제에 의해 실행될 때는 별다른 제약이 없음
- 하지만 사용자 프로그램을 실행할 때는 운영체제가 제어할 길이 없어짐
    - 따라서 지금 CPU가 운영체제를 위해 돌아가는지 User를 위해 돌아가는지를 알기 위해 **Mode Bit 를 이용하고 있음**
- 메모리는 오로지 **CPU에 의해서만 접근이 가능함~!!**

## Mode Bit


> 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치
{:.lead}


> Mode bit 을 통해 하드웨어적으로 두 가지 모드의 Operation 제공
> 
- 사용자 모드 (1) : 사용자 프로그램 수행
- 모니터(커널) 모드 (0) : OS 코드 수행

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/e1ba2a55-54e4-4752-86ae-35f969deb5f1)

✔︎ 보안을 해칠 수 잇는 중요한 명령어는 **`특권명령`**  이라 하며 이는 커널 모드에서만 돌아갈 수 잇음

✔︎ **인터럽트나 Exception 발생 시** 하드웨어가 mode bit 을 커널 모드로 전환

  - CPU에는 **Interrup line 이 존재하여 이를 통해 인터럽트를 파악**함

✔︎ 사용자 프로그램에게 넘기기 전에 mode bit 을 사용자 모드로 세팅

## Regisiter

> 📎 CPU 내부에 레지스터가 존재하고 연산의 input과 output 을 저장하기 위한 제일 빠른 HW

<br>
*Program Counter*

> 다음에 실행할 **명령어의 주소**(메모리에 존재함)를 가지고 있음
> 

## Timer

> 🚄 운영체제가 프로그램으로부터 CPU의 독점을 막기 위한 개념

> 일정 시간이 지난 후에도 일종 프로그램이 무한 루프를 돌면서 자원을 계속 쓰고자 하더라도 미리 세팅된 Timer 에 의해 인터럽트가 걸림
> 
- 정해진 시간이 흐른 뒤 OS에게 제어권이 넘어가도록
- 매 클럭 틱마다 1씩 감소하며 처리

## Interrupt

> 🤿 **현대의 운영체제는 인터럽트에 의해 구동됨 → 운영체제는 인터럽트가 들어왔을 때만 일을 한다.**

CPU가 모든 I/O 장치를 접근하는 명령은 `특권 명령` 임 → 따라서 운영체제에게 이를 부탁해야됨 

### System Call

> 사용자 프로그램이 운영체제의 `서비스를 받기 위해 커널 함수를 호출하는 것`
> 

ex) CPU가 일을 하다 disk 에 있는 파일을 읽어와야 한다 → **파일 read system call 호출**

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/d8eb7d80-0395-4222-a3fd-f3e211522677)

사용자 프로그램을 실행할 때는 Interrupt line 에 아무것도 안 들어와 있을텐데 디바이스 컨트롤러에게 어떻게 접급할까? 
→ **프로그램이 System Call 을 호출에서 인터럽트를 만든다.**

### Interrupt Flow

✔︎ 인터럽트 당한 시점의 **레지스터와 Program Counter를 저장 후 CPU의 제어를 인터럽트 처리 루틴에 넘김**

✔︎ 넓은 의미

- **하드웨어 인터럽트** : 하드웨어가 발생시킨 인터럽트
- **Trap (소프트웨어 인터럽트)**
    - Exception : 프로그램이 오류를 범한 경우
    - System Call : 프로그램이 커널 함수를 호출하는 경우

✔︎ **인터럽트 벡터** : 해당 인터럽트의 처리 루틴 주소를 가지고 있음

✔︎ **인터럽트 처리 루틴** : 해당 인터럽트를 처리하는 커널 함수

## Device Controller

> I/O 디바이스 컨트롤러 - HW
> 
- 해당 I/O 장치유형을 관리하는 **일종의 작은 CPU**
    - 펌웨어에 있는 명령어 대로 일을 함
- 제어 정보를 위해 **Control Register, Status Register를 가지고 있음**
- **로컬 버퍼**를 가짐 → 일종의 data register

I/O는 실제 device와 local buffer 사이에서 일어남

## 프로그램의 실행 (컴파일, 링커, 로더)

일반적으로 프로그램은 디스크에 이진 실행 파일로 존재 (a.out / prog.exe)

이를 실행하려면 프로그램을 **메모리로 가져와 프로세스 형태로 배치되어야 함**

### Program Execution Flow

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/1d4564c5-bae7-45f9-947b-dc161d885b54)

1. 소스 파일은 임의 물리 메모리 위치에 적재되도록 설계된 **오브젝트 파일로 컴파일 됨
⇒ 재배치 가능 오브젝트 파일**
2. **링커** : 오브젝트 파일을 하나의 이진 실행 파일로 결합 (다른 오브젝트 파일과 엮음)
3. **로더** : 이진 실행 파일을 **메모리에 적재하는데 사용** → CPU 코어에서 실행할 수 있는 상태가 됨
4. **링크 및 로드와 관련된 활동 = 재배치** ⇒ 최종 주소를 할당하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정

**ex) ./main 을 쉘에 입력했을 때**

1. fork() 시스템 콜을 사용하여 새 프로세스 생성
2. exec() 시스템 콜을 **로더를 호출하고 exec() 에 실행 파일 이름 전달**
3. 로더는 생성된 프로세스의 주소 공간을 사용하여 메모리에 적재

## 시스템 부팅

> 하드웨어는 운영체제를 어떻게 인식해서 사용할까? → 부팅 프로세스
> 

1. 부트스트랩 프로그램 또는 부트 로더가 커널의 위치를 찾는다.
2. 커널이 메모리에 적재되고 시작된다
3. 커널은 하드웨어를 초기화한다.
4. 루트 파일 시스템이 마운트 된다.

> 다단계 부팅 과정
> 
1. 컴퓨터 전원을 처음 켜면 BIOS 라 하는 비휘발성 펌웨어에 있는 소형 부트로더가 실행된다.
2. 초기 부트 로더는 부트 블록이라 하는 두 번째 부트 로더를 적재하는 작업만 실행한다.
3. 해당 부트 블록이 운영체제를 메모리에 적재한다.

# Quick Question 🙋

### 운영체제가 CPU에게 넘어가는 경우는 어떤 경우들인가?

> **인터럽트 라인을 세팅해야 하는 경우!!**
> 

그럼 누가 그 인터럽트 라인을 세팅하느냐?

- 하드웨어가 인터럽트를 걸었을 때
- 프로그램이 System Call을 호출했을 때

> **프로그램의 과도한 자원 할당을 막아야 하는 경우**
> 
- Timer에 의한 인터럽트
- 과도한 I/O의 대기 (키보드 입력 기다릴 때)

---

# 동기식 입출력과 비동기식 입출력

> **동기식 입출력 (synchronous I/O)**


✔︎ I/O 요청 후 입출력 작업이 **완료된 후에야 제어가 사용자 프로그램에게 넘어가는 것**

✔︎ 구현 방법 1

- I/O가 끝날 때까지 CPU 낭비
- 매 시점 하나의 I/O만 일어날 수 있음

✔︎ 구현 방법 2

- I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
- I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움 → 비동기식이기에 다른 프로세스도 I/O 처리를 요청할 수 있으니…
- 다른 프로그램에게 CPU 를 줌

> **비동기식 입출력 (asynchronous I/O)**
> 

✔︎ I/O 가 시작된 후 입출력 작업이 끝나기를 **기다리지 않고 제어가 사용자에게 즉시 넘어감**

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/8c68a51f-2dcd-4ee1-a865-11d5ec05d5ff)

**주요 포인트** : **결과를 보지 않고 그 후 작업을 이어가느냐** 의 차이

ex) 파일에 내용을 써라 → 쓰는 작업은 결과를 볼 필요가 없기에 비동기식으로 진행 가능

# DMA (Direct Memory Access)

> 🧶 **빠른 입출력 장치**를 메모리에 가까운 속도로 처리하기 위해 사용 → **인터럽트 처리 자체도 오버헤드**로 작용하기 때문!
{:.lead}


✔︎ CPU의 중재없이 device controller 가 **device의 buffer storage의 내용을 메모리**에 block 단위로 저장

✔︎ 따라서 byte 단위가 아니라 block 단위로 인터럽트 발생

![image](https://github.com/jungsiroo/jungsiroo.github.io/assets/54366260/d123269c-c87e-4d80-a970-ac1567f4cb1c)

- 메모리는 CPU만 접근 가능하지만 빠른 입출력 장치는 **잦은 인터럽트로 인해 오버헤드가 생김**
- 이를 보완하고자 메모리에 바로 접근하라고 만들어진 것이 **`DMA Controller`**
- 요지는 Block 단위로 처리해서 그 오버헤드를 줄인다는 것임

---

# 연습 문제

### 시스템 설계 시 계층화된 접근 방식의 주요 장점은 무엇인가? 계층화된 접근 방 식의 단점은 무엇인가?

```
장점 : 자신의 하위 계층의 서비스만 사용할 수 있기 때문에 테스트와 디버깅이 수월하다

단점 : 사용자의 메시지가 많은 계층을 거쳐야 하므로 오버헤드가 크다.
```