---
layout: post
title: 운영체제 - Deadlock
description: >
    운영체제 스터디 기록
hide_description: false
category: study
image:
  path: https://user-images.githubusercontent.com/54366260/235833580-f3259d21-36fc-4866-8d0e-dfa47fa3e594.png

---

**해당 썸네일은 `Wonkook Lee` 님이 만드신 [`Thumbnail-Maker`](https://wonkooklee.github.io/thumbnail_maker/){:target="_blank"} 를 이용하였습니다**
{:.figcaption}

* this unordered seed list will be replaced by the toc
{:toc}

# 🖨️ Intro

다중 프로그래밍 환경에서는 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁할 수 있다. 이러한 경쟁 속에서 대기 중인 스레드들이 요청한 자원이 다른 
스레드에 의해 점유되어 있고 그들도 다 대기 상태여서 상태를 다시는 변경시킬 수 없는 상태를 `교착상태` 라 한다.

# 🏎️ System Model

스레드는 기본적으로 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다. 스레드는 지정된 태스크를 수행하기 
위해 필요한 만큼의 자원을 요청할 수 있다. 일반적으로 아래와 같은 순서를 통해서만 자원을 사용할 수 있다.

> * `요청` : 자원을 요청하는 순서. 즉시 허용되지 않으면(예를 들어, mutex 락을 다른 스레드가 가지고 있는 경우), 요청 스레드는 자원을 얻을 때까지 
> 대기
> 
> * `사용` : 스레드는 자원에 대해 작업을 수행하는 순서(자원이 mutex 락이라면, 스레드는 자신의 임계구역에 접근할 수 있음)
>
> * `방출` : 스레드가 자원을 방출하는 순서
{:.lead}

_`다중 스레드 응용 개발자는 반드시 교착 상태의 가능성을 염두해 두고 개발하여야 한다.`_

# 📍 교착 상태의 특성

교착 상태가 일어나기 위해서는 필요조건들이 있다. 아래의 4가지가 그것이다.

> * `상호 배제(MUTual EXclusion)` : 최소한 하나의 자원이 비공유 모드로 점유되어야 한다. 비공유 모드에선 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
> 다른 스레드가 그 자원을 요청하면, 요청 스레드는 자원이 방출될 때까지 지연되어야 한다.
> 
> * `점유 대기` : 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.
>
> * `비선점` : 자원들을 선점할 수 없어야 한다. 강제적으로 방출될 수 없고 사용하고 있는 스레드에 의해 자발적 방출만이 가능하다.
> 
> * `순환 대기` : 대기하고 있는 스레드의 집합에서 A는 B가 점유한 자원을 대기하고 B는 C가 점유한 자원을 대기하고 ... Z는 A가 점유한 자원을 대기한다.
{:.lead}

교착 상태가 발생하려면 위 4가지의 조건이 충족되어야 한다. 여기서 순환 대기 조건은 점유하며 대기 조건을 포함하는데, 네 조건이 완전히 독립적이지 않은 것을 알 수 있다.
다만 각 조건을 별개로 간주하는 것이 유용하다. (아래에서 설명)

# 🧽 교착 상태 처리 방법

원칙적으로 교착 상태를 처리하는데는 아래 세 가지 다른 방법이 있다.

> * `무시` : 문제를 무시하고 발생하지 않은 척한다.
> 
> * `예방 or 회피` : 결코 교착 상태가 발생하지 않도록 보장하기 위해 예방하거나 회피하는 프로토콜을 사용한다.
>
> * `허용 & 복구` : 교착 상태를 허용하고 이를 복구하는 방법

위 처리 방법 중 현대 시스템은 어떤 방법을 채택하고 있을까? 바로 `무시`이다. 교착 상태를 처리하는 프로그램을 작성하는 것은 응용 개발자의 몫이며, 데이터베이스같은 경우
세 번째 해결안을 채택하곤 한다. 처리 방법을 알았으니 이를 좀 더 상세히 알아보자.

## ⚙️ 교착 상태 예방

교착 상태의 4가지 조건을 각각 별도로 검토함으로써 예방 방식에 대해 알아보자.

### 🧲 상호 배제

상호 배제 조건은 성립되어야 한다. 즉, 적어도 하나의 자원은 공유가 불가능한 자원이어야 한다. 하지만 공유 가능한 자원들은 배타적인 접근을 요구하지 않으며
따라서 교착 상태에 관련될 수가 없다.  ex) 읽기 전용 파일

하지만 일반적으로 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것은 `불가능`하다. 어떤 자원들은 근본적으로 공유가 불가능하기 때문이다. 
예를 들어 mutex 락은 동시에 여러 스레드가 공유할 수 없다.

### 🚜 점유 대기

시스템에서 점유 대기 조건이 발생하지 않도록 하려면 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다. 하지만 이것은 자원 요청의 동적 특성으로 인해
대부분의 응요 프로그램에는 실용적이지 않다

이것의 대안으로 스레드가 자원을 전혀 가지고 있지 않을 때만 자원을 요청할 수 있도록 허용한다. 즉 스레드가 추가의 자원을 요청할 수 있으려면, 자신에게 할당된 모든 자원을 
반드시 먼저 방출 해야한다.

이 두 개의 방안에는 2가지 주요 단점이 존재한다

> * 자원이 할당되었지만 장기간 사용되지 않을 수 있고 이에 따라 자원 이용률이 낮을 수 있다. 
>
> * 기아가 발생할 수 있다. → 인기 있는 여러 개의 자원이 필요한 스레드는 필요한 자원 중 적어도 하나는 항상 다른 스레드에 할당되므로 무한정 대기해야 할 수 있다.


### 🚇 비선점

해당 조건은 이미 할당된 자원이 선점되지 않아야 하는 것이다. 이 조건이 성립되지 않음을 보장하기 위해 아래와 같은 프로토콜을 사용할 수 있다.

어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 자원을 요청하면 → 현재 점유하고 잇는 모든 자원이 선점

즉 선점된 자원들은 그 스레드가 기다리고 있는 자원들의 리스트에 추가된다. 스레드는 자신이 요청하고 잇는 새로운 자원과 이미 점유하였던 옛 자원들을 다시 획득할 수 있을 때만 다시 시작할 수 있다.

이것의 대안으로 한 스레드가 어떤 자원들을 요청하면 사용 가능한지를 검사하는 것이다. 만약 불가능하면 그 자원들이 추가의 자원을 위해 대기하고 있는 어떤 다른 스레드에 할당되어 있는지를 검사한다.
만약 그렇다면 대기 중인 스레드로부터 원하는 자원을 선점해 이들을 요청하는 스레드에게 할당한다. 만일 자원을 이용할 수 없거나 다른 대기 스레드에 점유되어 있지 않다면, 요청 스레드는 반드시 대기해야 하며,
대기하는 동안 그 스레드의 자원들 중 일부는 다른 스레드가 이들을 요쳥하는 경우에만 선점될 수 있다.

`일반적으로 이 방법은 교착 상태가 가장 흔하게 발생하는 자원 유형인 mutex 락과 세마포어같은 자원에는 적용될 수 없다.`

### 🚀 순환 대기

앞선 3개의 예방 방법은 일반적으로 실용적이지 않다. 하지만 이번 조건을 무효화한다면 실용적인 해결책을 제공할 수 있는 기회를 제공한다.

순환 대기 조건이 성립되지 않도록 하는 한 가지 방법은 모든 자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요쳥하도록 하는 것이다.

$$ R = {R_1, R_2, ... , R_m} $$ 을 자원 유형의 집합이라고 하자. 각 스레드는 현재 점유한 자원의 앞이나 뒤 방향으로만 자원을 요구할 수 있다.
예를 들어 현재 스레드가 $$ R_2 $$ 를 점유하고 있다면 $$ R_1 $$ 이나 $$ R_3, R_4, ..., R_m $$ 만을 요청할 수 있다는 것이다.

## 🗽 교착 상태 회피

교착 상태 회피는 교착 상태가 발생하기 전에 교착 상태를 예상하여 안전한 상태(safe state)에서만 자원 요청을 허용하는 방법이다. 가장 단순하고
제일 유용한 모델은 각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것이다. 이러한 정보를 알게 되면 우리는 
교착 상태에 들어가지 않음을 보장하는 알고리즘 설계가 가능하다. 이를 통해 2개의 교착 상태 회피 알고리즘을 알아보자.


![image](https://velog.velcdn.com/images%2Fyanghl98%2Fpost%2Faf8e2076-f3ab-4239-aabd-7e3ca1290490%2Fimage.png)

단순하게 나타낸 회피
{:.figcaption}


### 🎠 Safe State

> safe sequence : 교착 상태를 발생 시키지 않고 자원을 할당하는 순서
>
> safe sequence 가 존재하여 모든 프로세스가 정상적으로 종료할 수 있는 상태
{:.lead}

### 🗼 Unsafe State

safe sequence 를 찾을 수 없다면 unsafe 하다고 한다. 하지만 꼭 unsafe 하다고 교착 상태로 가지는 않는다. 이는 교착 상태로 갈 수도 있다라는 뜻으로 해석하면
좋을 것 같다. 이 상태에 들어가게 되면 운영체제는 교착 상태가 일어날 수도 있는 자원 요청을 막을 수는 없다.


### 🚞 은행원 알고리즘

이 알고리즘은 은행에 비유되는 알고리즘으로 고객들이 현금을 찾으러 와도 일정한 순서에 의해 모든 고객의 요청을 다 들어줄 수 있는 알고리즘이다.


> 프로세스 시작시 자신이 필요한 각 자원의 최대 개수를 미리 선언
>
> 각 프로세스에서 자원요청이 있을때 요청을 승인하면 시스템이 안전한 상태로 유지되는 경우에만 자원을 할당.
>
> 불안정 상태가 예상되면 다른 프로세스가 끝날 때까지 대기.


## 🛹 회복

마지막으로 회복 기법이다. 이 회복 기법에는 간략히 2가지로 나눌 수 있다.


### 🎨 순환 대기 프로세스 중단

프로세스 또는 스레드를 중지시킴으로써 교착 상태를 제거하는 방법이다. 이를 2가지로 나눌 수 있다. 


> * 교착 상태 프로세스 모두 중지 : 확실하게 교착 상태 싸이클을 깨뜨리지만 비용이 크다. 이들 프로세스가 오랫동안 연산해왔던 것을 폐기해야 하고 이에 따라 다시 연산을 해야하기 때문
>
> * 교착 상태가 제거될 때까지 하나씩 종료 : 이는 각 프로세스가 중지될 때마다 교착 상태 탐지 알고리즘을 호출해 교착 상태인지 확인해야하므로 오버헤드가 크다. 

{:.lead}

이러한 결정은 CPU 스케쥴링 문제와 유사한 결정의 문제이며 경제적인 문제이다. 즉, 프로세스들을 중지시켰을 때 유발되는 비용이
최소인 프로세스들을 중지시켜야 한다. 불행하게도 최소 비용이라는 용어는 정확한 것이 아니다. 어느 프로세스를 선택할지 고를 때 다음과 같은 요인을 고민해봐야하기 때문이다.

* 프로세스의 우선순위
* 지금까지 프로세스가 수행된 시간과 지정된 일을 종료하는 데 더 필요한 시간
* 프로세스가 사용한 자원 유형과 수
* 종료까지 더 필요한 자원의 수
* 얼마나 많은 프로세스가 종료되어야 하는지

### 🪀 자원 선점

또 다른 방법으로는 자원 선점을 이용하여 교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속 선점해 이들을 다른 프로세스에 주는 방법이다. 이를 위해 다음 3가지를 고려해야 한다.

> 희생자 선택 : 어느 자원과 어느 프로세스들이 선점될 것인가?
>
> 후퇴 : 프로세스로부터 자원을 선점하려면, 그 프로세스를 어떻게 해야하는가? → 안전한 상태로 후퇴시키는 것이 최선이지만 안전 상태라는 것이 어떤 것이지를 결정하기 어렵기에 
> 가장 단순하게 완전 후퇴시킨다.
>
> 기아 상태 : 기아 상태가 발생하지 않는 것을 어떻게 보장할 것인가? 즉, 자원들이 동일한 프로세스로부터 항상 선점되지 않는다는 것을 어떻게 보장할 것인가?

{:.lead}

---

지금까지 Deadlock 에 대해 알아보았다. 교착상태의 필요조건, 예방, 회피, 복구 등을 보았는데 도움이 됐으면 한다.